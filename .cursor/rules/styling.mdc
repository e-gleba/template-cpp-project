# C++ Project Style Guide

**philosophy**: less code, fewer bugs. explicit > implicit. performance-aware. std lib over reinvention. Naming, file structure, and patterns should always be unix/clang/minimalist.

**references**:
- [boost design best practices](https://www.boost.org/doc/contributor-guide/design-guide/design-best-practices.html)
- [boost development best practices](https://www.boost.org/doc/contributor-guide/best-practices.html)
- c++ core guidelines (when boost doesn't conflict)
- Clang/LLVM infra source as best practice

---

## directory & file layout

```
dir-name/            # kebab-case for dirs (no spaces, camelcase, underscores)
  file_name.cpp      # snake_case for files (unix style)
  file_name.hpp      # snake_case for headers
  readme.md
  cmakelists.txt     # always lowercase
.cache/              # always ignore
.idea/ .vscode/      # ignore editor configs
build*/              # ignore build outputs
cmake-build*/        # ignore cmake build dirs
```

---

## naming: everything snake_case

```
namespace project_mod {};     // snake_case

class asset_manager {};       // snake_case, trailing underscore for privates

std::string_view file_path;   // snake_case
size_t n_objects;             // snake_case (never hungarian, never camel)
constexpr auto MAX_COUNT = 64;   // UPPER_SNAKE for constants
enum class save_status { ok, error };
template<typename T> concept serializable = requires(T t) { { t.serialize() } -> std::same_as<std::string>; };
void log_error(std::string_view msg) noexcept; // snake_case, explicit noexcept
```

- no camelCase, no PascalCase
- no hungarian, no member m_, no g_

---

## cmake (targets only, never global flags)

```
cmake_minimum_required(VERSION 3.21)
project(any_project LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

add_library(core STATIC src/core.cpp)
target_include_directories(core PUBLIC include)
target_compile_features(core PUBLIC cxx_std_20)
target_compile_options(core PRIVATE -Wall -Wextra -Wpedantic)

add_executable(app src/main.cpp)
target_link_libraries(app PRIVATE core)
```

- use targets for all settings (include, options, compile features)
- never set global flags (CMAKE_CXX_FLAGS)
- structure must allow simple disabling/enabling of tests, tools, options

---

## error handling

- explicit error propagation; use `std::expected<T,E>` or error returns, never silent
- exceptions only for true programmer errors (not regular control flow)
- `std::optional` for valid "not found"
- document what can fail (///, or markdown as appropriate)
- never swallow errors

---

## logging

- ascii only, no utf or emoji
- log format: lowercase, std::quoted() for strings, `=>` for actions, `==` for errors

```
std::cout << "=> load: " << std::quoted(filename) << '\n';
std::cerr << "== error: " << err_code << std::endl;
```

---

## documentation

- only open formats (Markdown, Mermaid preferred)
- public api uses doxygen/triple slash `///` for doc comments
- diagram code/dataflow in mermaid in docs if useful
- no docx, no proprietary

---

## api style / code economy

- prefer free functions over member functions; use classes only if they truly have state/identity
- all “manager” or “context” classes must have clear single-responsibility, minimal interface
- never use inheritance/polymorphism unless forced by external api or performance
- if using ECS or similar, composition over inheritance

---

## performance & resource management

- always prefer RAII for all resources
- minimize dynamic allocation; reserve() on vectors if size is predictable
- prefer std::vector over anything else for small/linear data sets; only use maps/sets for sparse/large data
- never use raw pointers for ownership; `std::unique_ptr` or `std::shared_ptr` (but prefer unique)
- optimize last, measure first — std::chrono for time

---

## clang-tidy/linters

- always provide and use a .clang-tidy with boost/cppcoreguidelines/modernize/performance/readability (see below)
- prefer per-target integration; never global unless you control all code
- in CI: run clang-tidy if native build, never for cross
- enforce snake_case (see clang-tidy config below)

---

## test integration

- provide `option(BUILD_TESTING "..." ON)` and use `enable_testing()` in top-level CMake
- tests must be opt-in, easy to disable for cross builds or consumers
- prefer Catch2 or doctest (header-only, minimal deps)
- always use ctest integration; register tests for ci

---

## universal cursor/editor rules

- always add styling.mdc in project root for Cursor
- ignore build/, .cache/, .idea/, etc
- "follow project style": instructs Cursor and other AIs to use these conventions when generating
- always edit in-place, never make “improvements” unless asked for
- codegen requests must specify: “snake_case, boost/cppcoreguidelines, explicit error, minimal api, unix logging, minimal dependencies”
- scripts: bash preferred (`set -e`, lowercase, quoted)

---

## summary checklist

- [ ] snake_case for all identifiers
- [ ] files as `file_name.ext`, dirs as `dir-name/`
- [ ] cmake: target properties, no global flags
- [ ] explicit error handling: expected/optional/exceptions
- [ ] logging: lowercase, ascii, std::quoted
- [ ] free functions preferred
- [ ] std lib over custom types
- [ ] const correctness enforced
- [ ] RAII for resources
- [ ] documented with doxygen-style ///
- [ ] tested with catch2/doctest if test present
- [ ] clang-tidy passes

**when in doubt**: check boost source (boost/filesystem, boost/asio), clang/llvm sources, not random github repos.
also do not overdocument, like document only where its required and may be misleading, the code must be self explanatory